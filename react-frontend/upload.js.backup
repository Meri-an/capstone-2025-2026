import React, { useState, useRef, useEffect } from 'react';
import axios from 'axios';
import ReactCrop from 'react-image-crop';
import 'react-image-crop/dist/ReactCrop.css';
import './App.css';

function Upload() {
  const [image, setImage] = useState(null);
  const [preview, setPreview] = useState(null);
  const [predictions, setPredictions] = useState([]);
  const [loading, setLoading] = useState(false);
  const [imageLoaded, setImageLoaded] = useState(false);
  const [imgDims, setImgDims] = useState({ width: 0, height: 0 });
  const [showPopup, setShowPopup] = useState(false); // State for controlling popup visibility
  const [showSolution, setShowSolution] = useState(false);
  const [crop, setCrop] = useState();
  const [completedCrop, setCompletedCrop] = useState(null);
  const [showCropModal, setShowCropModal] = useState(false);
  const [originalImage, setOriginalImage] = useState(null);

  const imageRef = useRef(null);
  const canvasRef = useRef(null);
  const containerRef = useRef(null);
  const cropImageRef = useRef(null);

 const hasDisease = () => {
    return predictions.some(pred => 
      pred.class.toLowerCase().includes('black sigatoka') || 
      pred.class.toLowerCase().includes('fusarium wilt')
    );
  };

  // Function to show solution popup
  const handleShowSolution = () => {
    setShowSolution(true);
  };

  // Function to close solution popup
  const handleCloseSolution = () => {
    setShowSolution(false);
  };

  // Get specific solution based on disease
  const getSolution = () => {
    const diseases = predictions.map(pred => pred.class.toLowerCase());
    
    if (diseases.some(d => d.includes('black sigatoka'))) {
      return {
        title: "Black Sigatoka Solution",
        treatments: [
          "Apply fungicides containing triazoles or strobilurins",
          "Remove and destroy infected leaves",
          "Improve air circulation by proper spacing",
          "Avoid overhead irrigation",
          "Use resistant banana varieties if available"
        ]
      };
    }
    
    if (diseases.some(d => d.includes('fusarium wilt'))) {
      return {
        title: "Fusarium Wilt Solution",
        treatments: [
          "Use disease-free planting material",
          "Practice crop rotation with non-host crops",
          "Solarize soil to reduce pathogen levels",
          "Apply biological control agents like Trichoderma",
          "Remove and destroy infected plants immediately",
          "Avoid moving soil from infected to healthy areas"
        ]
      };
    }
    
    return null;
  };

  // Modify your handleImageChange to show crop modal first
  const handleImageChange = async (e) => {
    const file = e.target.files[0];
    if (file) {
      const reader = new FileReader();
      reader.onloadend = () => {
        setOriginalImage(reader.result);
        setShowCropModal(true);
      };
      reader.readAsDataURL(file);
    }
  };

  // Function to handle crop and submit
  const handleCropComplete = async () => {
    if (!completedCrop || !cropImageRef.current) {
      // If no crop, use original image
      await processImage(originalImage);
      return;
    }

    const canvas = document.createElement('canvas');
    const image = cropImageRef.current;
    const scaleX = image.naturalWidth / image.width;
    const scaleY = image.naturalHeight / image.height;

    canvas.width = completedCrop.width;
    canvas.height = completedCrop.height;
    const ctx = canvas.getContext('2d');

    ctx.drawImage(
      image,
      completedCrop.x * scaleX,
      completedCrop.y * scaleY,
      completedCrop.width * scaleX,
      completedCrop.height * scaleY,
      0,
      0,
      completedCrop.width,
      completedCrop.height
    );

    canvas.toBlob(async (blob) => {
      const croppedImageUrl = URL.createObjectURL(blob);
      await processImage(croppedImageUrl, blob);
    });
  };

  // Process image and send to API
  const processImage = async (imageUrl, blob = null) => {
    document.getElementById('upload-hr').style.display = 'none';
    const appUploadElements = document.getElementsByClassName('App-upload');
    if (appUploadElements.length > 0) {
      appUploadElements[0].style.display = 'none';
    }
    document.querySelector('section').style.display = 'block';

    if (canvasRef.current) {
      const ctx = canvasRef.current.getContext('2d');
      ctx.clearRect(0, 0, canvasRef.current.width, canvasRef.current.height);
    }

    setPreview(imageUrl);
    setImageLoaded(false);
    setShowPopup(false);
    setShowSolution(false);
    setShowCropModal(false);
    setPredictions([]);
    setLoading(true);

    const formData = new FormData();
    if (blob) {
      formData.append('image', blob, 'cropped.jpg');
    } else {
      // Convert data URL to blob
      const response = await fetch(imageUrl);
      const imageBlob = await response.blob();
      formData.append('image', imageBlob, 'image.jpg');
    }

    try {
      const response = await axios.post('http://localhost:8000/api/predict/', formData, {
        headers: {
          'Content-Type': 'multipart/form-data',
        },
      });
      setPredictions(response.data.predictions);
      setShowPopup(true);
    } catch (error) {
      console.error('Error making prediction:', error);
      alert('Error making prediction! Check console for details.');
    } finally {
      setLoading(false);
    }
  };

  // Close popup when clicking outside of it
  useEffect(() => {
    const handleClickOutside = (event) => {
      if (showPopup && !event.target.closest('.popup-content')) {
        setShowPopup(false);
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, [showPopup]);

  // Calculate dimensions to fit within container while maintaining aspect ratio
  const calculateDisplayDimensions = (naturalWidth, naturalHeight) => {
    const maxWidth = 500;
    const maxHeight = 500;
    
    let width = naturalWidth;
    let height = naturalHeight;
    
    if (width > maxWidth) {
      const ratio = maxWidth / width;
      width = maxWidth;
      height = height * ratio;
    }
    
    if (height > maxHeight) {
      const ratio = maxHeight / height;
      height = maxHeight;
      width = width * ratio;
    }
    
    return { width, height };
  };

  useEffect(() => {
    if (preview && predictions.length === 0 && canvasRef.current) {
      const ctx = canvasRef.current.getContext('2d');
      ctx.clearRect(0, 0, canvasRef.current.width, canvasRef.current.height);
    } else if (imageLoaded && predictions.length > 0) {
      drawBoundingBoxes();
    }
  }, [predictions, preview, imageLoaded, imgDims]);

  const drawBoundingBoxes = () => {
    const canvas = canvasRef.current;
    const image = imageRef.current;
    if (!canvas || !image || predictions.length === 0) return;

    const ctx = canvas.getContext('2d');
    const displayDims = calculateDisplayDimensions(image.naturalWidth, image.naturalHeight);
    
    // Set canvas dimensions to match the displayed image
    canvas.width = displayDims.width;
    canvas.height = displayDims.height;
    
    // Clear the canvas before drawing new boxes
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Calculate scaling factors
    const scaleX = displayDims.width / image.naturalWidth;
    const scaleY = displayDims.height / image.naturalHeight;
    
    // Draw each bounding box
    predictions.forEach((prediction) => {
      const { x1, y1, x2, y2 } = prediction.bbox;
      const label = `${prediction.class} ${(prediction.confidence * 100).toFixed(1)}%`;
      
      // Scale coordinates to match displayed image
      const scaledX1 = x1 * scaleX;
      const scaledY1 = y1 * scaleY;
      const scaledX2 = x2 * scaleX;
      const scaledY2 = y2 * scaleY;
      
      ctx.strokeStyle = '#FF0000';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.rect(scaledX1, scaledY1, scaledX2 - scaledX1, scaledY2 - scaledY1);
      ctx.stroke();
      
      ctx.fillStyle = '#FF0000';
      ctx.font = '16px Arial';
      const textWidth = ctx.measureText(label).width;
      ctx.fillRect(scaledX1, scaledY1 - 20, textWidth + 10, 20);
      
      ctx.fillStyle = '#FFFFFF';
      ctx.fillText(label, scaledX1 + 5, scaledY1 - 5);
    });
  };

  return (
    <div className="App">
      <div className="App-upload">
        <h2 id="upload-hr">Upload an image of <br></br> banana leaves for detection</h2>
        <form onSubmit={e => e.preventDefault()} style={{ marginBottom: '20px' }}>
          <label htmlFor="file-upload" style={{ marginRight: '10px' }}>
            <input
              id="file-upload"
              type="file"
              onChange={handleImageChange}
              accept="image/*"
              style={{ display: 'none' }}
            />
            <button
              id="upload-btn"
              type="button"
              onClick={() => document.getElementById('file-upload').click()}
            >
              Upload
            </button>
          </label>
        </form>
      </div>
      
      <section style={{ display: 'none', padding: '20px' }}>
        <div style={{ display: 'flex', flexDirection: 'row', alignItems: 'center', marginBottom: '20px', justifyContent: 'center' }}>
    <h3>Preview</h3>
    <label htmlFor="file-upload" style={{ marginLeft: '10px' }}>
      <input
        id="file-upload"
        type="file"
        onChange={handleImageChange}
        accept="image/*"
        style={{ display: 'none' }}
      />
      <button
        id="upload-btn"
        type="button"
        onClick={() => document.getElementById('file-upload').click()}
      >
        <span className="material-icons" style={{ color: '#fff', fontSize: 24, verticalAlign: 'middle' }}>
          upload
        </span>
      </button>
    </label>
  </div> 
  
  {/* Preview Area with Image, Canvas, and Results Sidebar */}
  {preview && (
    <div className="preview-container">
      {/* Image and Canvas */}
      <div className="preview-wrapper">
        <img
          ref={imageRef}
          src={preview}
          alt="Preview"
          style={{
            display: 'block',
            maxWidth: '100%',
            maxHeight: '500px',
            width: 'auto',
            height: 'auto'
          }}
          onLoad={e => {
            setImageLoaded(true);
            const displayDims = calculateDisplayDimensions(
              e.target.naturalWidth, 
              e.target.naturalHeight
            );
            setImgDims(displayDims);
          }}
        />
        <canvas
          ref={canvasRef}
          style={{
            position: 'absolute',
            top: 0,
            left: 0,
            width: '100%',
            height: '100%',
            pointerEvents: 'none'
          }}
        />
      </div>
      
       {/* Detection Results Sidebar */}
            <div className="results-sidebar">
              {loading ? (
                <p>Processing...</p>
              ) : predictions.length > 0 ? (
                <div>
                  <h2>Detection Results</h2>
                  <ul className="results-list">
                    {predictions.map((pred, index) => (
                      pred.class.toLowerCase() === 'fusarium wilt' ||   pred.class.toLowerCase() === 'black sigatoka' ?(
                        <li key={index}>
                          {pred.class} ({(pred.confidence * 100).toFixed(1)}%)
                        </li>
                      ) : (
                        <li key={index} style={{color: '#ff4444', fontStyle: 'italic'}}>
                          No detection results
                        </li>
                      )
                    ))}
                  </ul>
                  
                  {/* Recommended Solution Button */}
                  {hasDisease() && (
                    <button
                      id="solution-btn"
                      onClick={handleShowSolution}
                      style={{
                        display: 'inline-block',
                        backgroundColor: '#e74c3c',
                        color: 'white',
                        padding: '12px 24px',
                        border: 'none',
                        borderRadius: '25px',
                        cursor: 'pointer',
                        fontSize: '16px',
                        marginTop: '15px',
                        transition: 'background-color 0.3s',
                        fontWeight: 'bold'
                      }}
                    >
                      Recommended Solution
                    </button>
                  )}
                </div>
              ) : (
                <div>
                  <h2>No predictions found</h2>
                  <p 
                    style={{textDecoration: 'underline', fontWeight: 'bold', cursor: 'pointer'}} 
                    onClick={() => document.getElementById('file-upload').click()}
                  >
                    Upload valid image.
                  </p>
                </div>
              )}
            </div>
          </div>
        )}
        
        {/* Popup Modal for Results 
        {showPopup && (
          <div className="popup-overlay">
            <div className="popup-content">
              <button 
                className="popup-close" 
                onClick={() => setShowPopup(false)}
                aria-label="Close popup"
              >
                &times;
              </button>

             
              
             
            </div>
          </div> 
        )}  */}


         {/* Solution Popup Modal */}
      {showSolution && (
        <div className="popup-overlay">
          <div className="popup-content">
            <button 
              className="popup-close" 
              onClick={handleCloseSolution}
              aria-label="Close solution popup"
            >
              &times;
            </button>
            
            {getSolution() && (
              <div>
                <h2 style={{ color: '#e74c3c', marginBottom: '20px' }}>
                  {getSolution().title}
                </h2>
                <h3 style={{ color: '#302e2e', marginBottom: '15px' }}>Recommended Treatments:</h3>
                <ul style={{ textAlign: 'left', paddingLeft: '20px' }}>
                  {getSolution().treatments.map((treatment, index) => (
                    <li key={index} style={{ marginBottom: '10px', lineHeight: '1.4' }}>
                      {treatment}
                    </li>
                  ))}
                </ul>
                <p style={{ marginTop: '20px', fontStyle: 'italic', color: '#666' }}>
                  Consult with agricultural experts for specific application rates and timing.
                </p>
              </div>
            )}
          </div>
        </div>
      )}
      </section>


      
    </div>

    
  );

 
}

export default Upload;